//-*- mode: rust -*-
use rug::Integer;
use liblumen_diagnostics::{ByteSpan, ByteIndex, Diagnostic, Label};

use crate::lexer::{Token, Symbol, Ident};
use crate::preprocessor::PreprocessorError;

use super::ParseError;
use super::ast::*;

grammar(errs: &mut Vec<ParseError>);

// The following are _not_ non-terminals, but macros
// which can be identified by the generic type parameter,
//
// Currently all of the macros expect the name of the corresponding
// non-terminal to have a type of the same name, a macro can
// be written to handle differing non-terminal/type combinations by
// adding a second type parameter used only in the type signature

// Semicolon-delimited with at least one element
Semi<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

// Comma-delimited with at least one element
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

// Comma-delimited with zero or more elements
CommaOpt<T>: Vec<T> = {
    <v:(<T> ",")*> => v,
};

// Dash-delimited with at least one element
Dash<T>: Vec<T> = {
    <v:(<T> "-")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Module: Module = {
    <l:@L> "COMMENT"* "-" "module" "(" <name:atom>  ")" "." "COMMENT"* <body:ModuleBody?> <r:@R> => {
        let body = match body {
            None => Vec::new(),
            Some(body) => body,
        };
        Module::new(ByteSpan::new(l, r), name, body)
    }
};

ModuleBody: Vec<TopLevel> = TopLevel+;

TopLevel: TopLevel = {
    <FunctionDefinition> => TopLevel::Function(<>),
    AttributeDefinition,
};

// Top-level Functions

FunctionDefinition: Function = {
    <l:@L> <clauses:Semi<FunctionHead>> "." <r:@R>
        => Function::new(errs, span!(l, r), clauses),
};

FunctionHead: FunctionClause = {
    <l:@L> <a:atom> "(" ")" <g:Guards?> "->" <body:Comma<Expr>> <r:@R> => {
        FunctionClause::new(span!(l, r), Some(a), Vec::new(), g, body)
    },
    <l:@L> <a:atom> "(" <params:Comma<Pattern>> ")" <g:Guards?> "->" <body:Comma<Expr>> <r:@R> => {
        FunctionClause::new(span!(l, r), Some(a), params, g, body)
    }
};

FunctionClause: FunctionClause = {
    <l:@L> <a:atom?> "(" ")" <g:Guards?> "->" <body:Comma<Expr>> <r:@R> => {
        FunctionClause::new(span!(l, r), a, Vec::new(), g, body)
    },
    <l:@L> <a:atom?> "(" <params:Comma<Pattern>> ")" <g:Guards?> "->" <body:Comma<Expr>> <r:@R> => {
        FunctionClause::new(span!(l, r), a, params, g, body)
    }
};

Guards: Vec<Guard> = "when" <Semi<Guard>>;

Guard: Guard = <l:@L> <conditions:Comma<Expr>> <r:@R>
    => Guard { span: span!(l, r), conditions };


FunctionName: FunctionName = {
    <l:@L> <function:atom> "/" <arity:arity> <r:@R> =>
        FunctionName::Resolved { span: span!(l, r), module: None, function, arity: Some(arity) },
};

// Attributes

AttributeDefinition: TopLevel = {
    <l:@L> "-" "record" "(" <name:atom> "," <fields:TypedRecordFields> ")" "." <r:@R>
        => TopLevel::Record(Record { span: span!(l, r), name, fields }),
    <l:@L> "-" "vsn" "(" <vsn:Atomic> ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::Vsn { span: span!(l, r), vsn }),
    <l:@L> "-" "compile" "(" <opts:Atomic> ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::Compile { span: span!(l, r), opts }),
    <l:@L> "-" "import" "(" <module:atom> "," "[" <imports:Comma<FunctionName>> "]" ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::Import { span: span!(l, r), module, imports }),
    <l:@L> "-" "export" "(" "[" <exports:Comma<FunctionName>> "]" ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::Export { span: span!(l, r), exports }),
    <l:@L> "-" "export_type" "(" "[" <exports:Comma<FunctionName>> "]" ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::ExportType { span: span!(l, r), exports }),
    <l:@L> "-" "type" <def:TypeDef> <r:@R>
        => TopLevel::Attribute(Attribute::type_def(span!(l, r), false, def)),
    <l:@L> "-" "opaque" <def:TypeDef> <r:@R>
        => TopLevel::Attribute(Attribute::type_def(span!(l, r), true, def)),
    <l:@L> "-" "spec" <spec:TypeSpec> <r:@R>
        => TopLevel::Attribute(Attribute::type_spec(span!(l, r), spec)),
    <l:@L> "-" "callback" <spec:TypeSpec> <r:@R>
        => TopLevel::Attribute(Attribute::callback(span!(l, r), spec)),
    <l:@L> "-" <name:atom> "(" <value:Expr> ")" "." <r:@R>
        => TopLevel::Attribute(Attribute::Custom { span: span!(l, r), name, value }),
};

TypedRecordFields: Vec<RecordField> = {
    "{" "}" => Vec::new(),
    "{" <Comma<TypedRecordField>> "}"
};

TypedRecordField: RecordField = {
    <l:@L> <name:atom> <value:("=" <Expr>)?> <ty:("::" <TopType100>)?> <r:@R>
        => RecordField { span: span!(l, r), name: Name::Atom(name), value, ty },
};

// Type Specifications

TypeDef: TypeDefinition = {
    "(" <TypeDef100> ")" => (<>),
    TypeDef100,
};

TypeDef100: TypeDefinition = {
    <name:atom> "(" <params:CommaOpt<Ident>> ")" "::" <ty:TopType100> "."
        => TypeDefinition { name, params, ty },
};

TypeSpec: TypeSpec = {
    "(" <module:(<Ident> ":")?> <function:Ident> <sigs:Semi<TypeSig>> ")" "."
        => TypeSpec { module, function, sigs },
    <module:(<Ident> ":")?> <function:Ident> <sigs:Semi<TypeSig>> "."
        => TypeSpec { module, function, sigs },
};

TypeSig: TypeSig = {
    <l:@L> "(" ")" "->" <ret:TopType100> <guards:("when" <Comma<TypeGuard>>)?> <r:@R>
        => TypeSig { sig: FunType::Fun { span: span!(l, r), params: Vec::new(), ret: Box::new(ret) }, guards },
    <l:@L> "(" <params:Comma<TopType>> ")" "->" <ret:TopType100> <guards:("when" <Comma<TypeGuard>>)?> <r:@R>
        => TypeSig { sig: FunType::Fun { span: span!(l, r), params, ret: Box::new(ret) }, guards },
};

TypeGuard: TypeGuard = {
    // is_subtype is not supported >OTP 19, but is allowed for backwards compatibility
    <l:@L> <name:atom> "(" <var:Ident> "," <ty:TopType> ")" <r:@R> =>? {
        match name.name.as_str().get() {
            "is_subtype" =>
                Ok(TypeGuard { span: span!(l, r), var, ty }),
            name => {
                Err(lalrpop_util::ParseError::User {
                    error: PreprocessorError::Diagnostic(
                        Diagnostic::new_error("invalid type constraint")
                            .with_label(Label::new_primary(span!(l, r))
                                .with_message(format!("expected constraint in the form `Name :: Type`")))
                    )
                })
            }
        }
    },
    <l:@L> <var:Ident> "::" <ty:TopType100> <r:@R>
        => TypeGuard { span: span!(l, r), var, ty },
};

TopType: Type = {
    <l:@L> <name:Ident> "::" <ty:TopType100> <r:@R>
        => Type::Annotated { span: span!(l, r), name, ty: Box::new(ty)  },
    TopType100,
};

TopType100: Type = {
    <l:@L> <lhs:Type200> "|" <rhs:TopType100> <r:@R>
        => Type::union(span!(l, r), lhs, rhs),
    Type200,
};

Type200: Type = {
    <l:@L> <lhs:Type300> ".." <rhs:Type300> <r:@R>
        => Type::Range { span: span!(l, r), start: Box::new(lhs), end: Box::new(rhs) },
    Type300,
};

Type300: Type = {
    <l:@L> <lhs:Type300> <op:TypeAddOp> <rhs:Type400> <r:@R>
        => Type::BinaryOp { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Type400,
};

Type400: Type = {
    <l:@L> <lhs:Type400> <op:TypeMultOp> <rhs:Type500> <r:@R>
        => Type::BinaryOp { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Type500,
};

Type500: Type = {
    <l:@L> <op:TypeUnaryOp> <rhs:Type600> <r:@R>
        => Type::UnaryOp { span: span!(l, r), op, rhs: Box::new(rhs) },
    Type600,
};

Type600: Type = {
    <l:@L> <fun:atom> "(" ")" <r:@R>
        => Type::Generic { span: span!(l, r), fun, params: Vec::new() },
    <l:@L> <fun:atom> "(" <params:Comma<TopType>> ")" <r:@R>
        => Type::Generic { span: span!(l, r), fun, params },
    Type700,
};

Type700: Type = {
    <l:@L> <module:atom> ":" <fun:atom> "(" ")" <r:@R>
        => Type::Remote { span: span!(l, r), module, fun, args: Vec::new() },
    <l:@L> <module:atom> ":" <fun:atom> "(" <args:Comma<TopType>> ")" <r:@R>
        => Type::Remote { span: span!(l, r), module, fun, args },
    TypeMax,
};

TypeMax: Type = {
    "(" <ty:TopType> ")"
        => ty,
    <l:@L> "[" "]" <r:@R>
        => Type::Nil(span!(l, r)),
    <l:@L> "[" <lt:TopType> "]" <r:@R>
        => Type::List(span!(l, r), Box::new(lt)),
    <l:@L> "[" <lt:TopType> "," "..." "]" <r:@R>
        => Type::NonEmptyList(span!(l, r), Box::new(lt)),
    <l:@L> "{" "}" <r:@R>
        => Type::Tuple(span!(l, r), Vec::new()),
    <l:@L> "{" <et:Comma<TopType>> "}" <r:@R>
        => Type::Tuple(span!(l, r), et),
    <l:@L> "#" "{"  "}" <r:@R>
        => Type::Map(span!(l, r), Vec::new()),
    <l:@L> "#" "{" <ft:Comma<MapFieldType>> "}" <r:@R>
        => Type::Map(span!(l, r), ft),
    <l:@L> "#" <record:atom> "{" "}" <r:@R>
        => Type::Record(span!(l, r), record, Vec::new()),
    <l:@L> "#" <record:atom> "{" <ft:Comma<RecordFieldType>> "}" <r:@R>
        => Type::Record(span!(l, r), record, ft),
    BinaryType,
    <name:atom_or_var>
        => Type::Name(name),
    <l:@L> <i:int> <r:@R>
        => Type::Integer(span!(l, r), i),
    <l:@L> <c:char> <r:@R>
        => Type::Char(span!(l, r), c),
    <FunType>
        => Type::Fun(<>),
};

BinaryType: Type = {
    <l:@L> "<<" ">>" <r:@R>
        => Type::Binary(span!(l, r), 0, 0),
    <l:@L> "<<" ident ":" <m:int> ">>" <r:@R>
        => Type::Binary(span!(l, r), m, 0),
    <l:@L> "<<" ident ":" ident "*" <n:int> ">>" <r:@R>
        => Type::Binary(span!(l, r), 0, n),
    <l:@L> "<<" ident ":" <m:int> "," ident ":" ident "*" <n:int> ">>" <r:@R>
        => Type::Binary(span!(l, r), m, n),
};

FunType: FunType = {
    <l:@L> "fun" "(" "..." ")" <r:@R>
        => FunType::Any(span!(l, r)),
    <l:@L> "fun" "(" "(" ")" "->" <ret:TopType> ")" <r:@R>
        => FunType::Fun { span: span!(l, r), params: Vec::new(), ret: Box::new(ret) },
    <l:@L> "fun" "(" "(" <params:Comma<TopType>> ")" "->" <ret:TopType> ")" <r:@R>
        => FunType::Fun { span: span!(l, r), params, ret: Box::new(ret) },
};

MapFieldType: Type = {
    <l:@L> <key:TopType100> "=>" <val:TopType100> <r:@R>
        => Type::KeyValuePair(span!(l, r), Box::new(key), Box::new(val)),
    <l:@L> <key:TopType100> ":=" <val:TopType100> <r:@R>
        => Type::KeyValuePair(span!(l, r), Box::new(key), Box::new(val)),
};

RecordFieldType: Type = {
    <l:@L> <key:atom> "::" <val:TopType100> <r:@R>
        => Type::Field(span!(l, r), key, Box::new(val)),
};

// Pattern Matching

Pattern: Pattern = {
    <l:@L> <lhs:Pattern200> "=" <rhs:Pattern> <r:@R>
        => Pattern::Match(span!(l, r), Box::new(lhs), Box::new(rhs)),
    Pattern200
};

Pattern200: Pattern = {
    <l:@L> <lhs:Pattern300> <op:CompOp> <rhs:Pattern300> <r:@R>
        => Pattern::BinaryExpr(span!(l, r), Box::new(lhs), op, Box::new(rhs)),
    Pattern300
};

Pattern300: Pattern = {
    <l:@L> <lhs:Pattern400> <op:ListOp> <rhs:Pattern300> <r:@R>
        => Pattern::BinaryExpr(span!(l, r), Box::new(lhs), op, Box::new(rhs)),
    Pattern400
};

Pattern400: Pattern = {
    <l:@L> <lhs:Pattern400> <op:AddOp> <rhs:Pattern500> <r:@R>
        => Pattern::BinaryExpr(span!(l, r), Box::new(lhs), op, Box::new(rhs)),
    Pattern500
};

Pattern500: Pattern = {
    <l:@L> <lhs:Pattern500> <op:MultOp> <rhs:Pattern600> <r:@R>
        => Pattern::BinaryExpr(span!(l, r), Box::new(lhs), op, Box::new(rhs)),
    Pattern600
};

Pattern600: Pattern = {
    <l:@L> <op:PrefixOp> <rhs:Pattern700> <r:@R>
        => Pattern::UnaryExpr(span!(l, r), op, Box::new(rhs)),
    MapPattern,
    Pattern700
};

Pattern700: Pattern = {
    RecordPattern,
    PatternMax
};

PatternMax: Pattern = {
    <i:Ident> => Pattern::Var(i),
    <a:Atomic> => {
        match a {
            Expr::Literal(literal) => Pattern::Literal(literal),
            _ => panic!("internal error: expected Expr::Literal here")
        }
    },
    ListPattern,
    <b:Binary> => match b {
        Expr::Binary(span, elements) => Pattern::Binary(span, elements),
        _ => panic!("internal error: expected Expr::Binary here")
    },
    <t:Tuple> => match t {
        Expr::Tuple(span, elements) => Pattern::Tuple(span, elements),
        _ => panic!("internal error: expected Expr::Tuple here")
    },
    "(" <Pattern> ")"
};

ListPattern: Pattern = {
    <l:@L> "[" "]" <r:@R> => Pattern::Nil(span!(l, r)),
    <l:@L> "[" <head:Pattern> <tail:TailPattern> <r:@R> => Pattern::Cons(span!(l, r), Box::new(head), Box::new(tail))
};

TailPattern: Pattern = {
    <l:@L> "]" <r:@R>
        => Pattern::Nil(span!(l, r)),
    "|" <Pattern> "]",
    <l:@L> "," <head:Pattern> <tail:TailPattern> <r:@R>
        => Pattern::Cons(span!(l, r), Box::new(head), Box::new(tail))
};

MapPattern: Pattern = {
    <l:@L> "#" <fields:MapTuplePattern> <r:@R>
        => Pattern::Map(span!(l, r), None, fields),
    <l:@L> <lhs:PatternMax> "#" <fields:MapTuplePattern> <r:@R>
        => Pattern::Map(span!(l, r), Some(Box::new(lhs)), fields),
    <l:@L> <lhs:MapPattern> "#" <fields:MapTuplePattern> <r:@R>
        => Pattern::Map(span!(l, r), Some(Box::new(lhs)), fields),
};

MapTuplePattern: Vec<MapFieldPattern> = {
    "{" "}" => Vec::new(),
    "{" <Comma<MapFieldPattern>> "}"
};

MapFieldPattern: MapFieldPattern = {
    MapFieldAssocPattern,
    MapFieldExactPattern
};
MapFieldAssocPattern: MapFieldPattern = {
    <l:@L> <key:MapKeyPattern> "=>" <value:Pattern> <r:@R> => MapFieldPattern::Assoc { span: span!(l, r), key, value }
};
MapFieldExactPattern: MapFieldPattern = {
    <l:@L> <key:MapKeyPattern> ":=" <value:Pattern> <r:@R> => MapFieldPattern::Exact { span: span!(l, r), key, value }
};

MapKeyPattern: Pattern = Pattern;

RecordPattern: Pattern = {
    <l:@L> "#" <name:atom> "." <field:atom> <r:@R>
        => Pattern::RecordIndex(span!(l, r), name, field),
    <l:@L> "#" <name:atom> <fields:RecordTuplePattern> <r:@R>
        => Pattern::Record(span!(l, r), name, fields),
};

RecordTuplePattern: Vec<RecordFieldPattern> = {
    "{" "}" => Vec::new(),
    "{" <Comma<RecordFieldPattern>> "}"
};

RecordFieldPattern: RecordFieldPattern = {
    <l:@L> <name:atom_or_var> "=" <value:Pattern> <r:@R>
        => RecordFieldPattern { span: span!(l, r), name, value: Some(value) },
};

// Expressions

pub Expr: Expr = {
    <l:@L> "catch" <e:Expr> <r:@R> => Expr::Catch(span!(l, r), Box::new(e)),
    Expr100,
}

Expr100: Expr = {
    // We would like to use Pattern200 here, but this leads to an ambiguity conflict
    // between non-terminals which are same in structure but different type, e.g. Tuple/TuplePattern,
    // so we just need to be aware that Expr::Match is really a pattern expression
    <l:@L> <lhs:Expr150> "=" <rhs:Expr100> <r:@R>
        => Expr::Match(span!(l, r), Box::new(lhs), Box::new(rhs)),
    <l:@L> <lhs:Expr150> "!" <rhs:Expr100> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op: BinaryOp::Send, rhs: Box::new(rhs) },
    Expr150
};

Expr150: Expr = {
    <l:@L> <lhs:Expr160> "orelse" <rhs:Expr150> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op: BinaryOp::OrElse, rhs: Box::new(rhs) },
    Expr160
};

Expr160: Expr = {
    <l:@L> <lhs:Expr200> "andalso" <rhs:Expr160> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op: BinaryOp::AndAlso, rhs: Box::new(rhs) },
    Expr200
};

Expr200: Expr = {
    <l:@L> <lhs:Expr300> <op:CompOp> <rhs:Expr300> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Expr300
};

Expr300: Expr = {
    <l:@L> <lhs:Expr400> <op:ListOp> <rhs:Expr300> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Expr400
};

Expr400: Expr = {
    <l:@L> <lhs:Expr400> <op:AddOp> <rhs:Expr500> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Expr500
};

Expr500: Expr = {
    <l:@L> <lhs:Expr500> <op:MultOp> <rhs:Expr600> <r:@R>
        => Expr::BinaryExpr { span: span!(l, r), lhs: Box::new(lhs), op, rhs: Box::new(rhs) },
    Expr600
};

Expr600: Expr = {
    <l:@L> <op:PrefixOp> <rhs:Expr700> <r:@R>
        => Expr::UnaryExpr { span: span!(l, r), op, rhs: Box::new(rhs) },
    MapExpr,
    Expr700
};

Expr700: Expr = {
    Apply,
    RecordExpr,
    Expr800
};

Expr800: Expr = {
    <l:@L> <lhs:ExprMax> ":" <rhs:ExprMax> <r:@R>
        => Expr::Remote { span: span!(l, r), module: Box::new(lhs), function: Box::new(rhs) },
    ExprMax
};

ExprMax: Expr = {
    <i:Ident> => Expr::Var(i),
    Atomic,
    Tuple,
    List,
    Binary,
    ListComprehension,
    BinaryComprehension,
    "(" <Expr> ")",
    <l:@L> "begin" <body:Comma<Expr>> "end" <r:@R>
        => Expr::Begin(span!(l, r), body),
    If,
    Case,
    Receive,
    Try,
    Fun,
};

Fun: Expr = {
    <l:@L> "fun" <function:atom> "/" <arity:arity> <r:@R> =>
        Expr::FunctionName(FunctionName::Resolved { span: span!(l, r), module: None, function, arity: Some(arity) }),
    <l:@L> "fun" <module:atom_or_var> ":" <function:atom_or_var> "/" <arity:arity> <r:@R> =>
        Expr::FunctionName(FunctionName::detect(span!(l, r), Some(module), function, arity)),
    <l:@L> "fun" <clauses:Semi<FunctionHead>> "end" <r:@R>
        => Expr::Fun(Function::new(errs, span!(l, r), clauses)),
};

If: Expr = {
    <l:@L> "if" <clauses:Semi<IfClause>> "end" <r:@R>
        => Expr::If(span!(l, r), clauses)
};
IfClause: IfClause = {
    <l:@L> <conditions:Comma<Expr>> "->" <body:Comma<Expr>> <r:@R>
        => IfClause(span!(l, r), conditions, body)
};

Case: Expr = {
    <l:@L> "case" <input:Expr> "of" <clauses:Semi<Clause>> "end" <r:@R>
        => Expr::Case(span!(l, r), Box::new(input), clauses)
};

Receive: Expr = {
    <l:@L> "receive" <after:After> "end" <r:@R>
        => Expr::Receive { span: span!(l, r), clauses: None, after: Some(after) },
    <l:@L> "receive" <clauses:Semi<Clause>> <after:After?> "end" <r:@R>
        => Expr::Receive { span: span!(l, r), clauses: Some(clauses), after }
};

After: Timeout = {
    <l:@L> "after" <timeout:Expr> "->" <body:Comma<Expr>> <r:@R>
        => Timeout(span!(l, r), Box::new(timeout), body)
};

Try: Expr = {
    <l:@L> "try" <exprs:Comma<Expr>> "of" <clauses:Semi<Clause>> <catch:TryCatch>
        => Expr::Try { span: span!(l, catch.2), exprs: Some(exprs), clauses: Some(clauses), catch_clauses: catch.0, after: catch.1 },
    <l:@L> "try" <exprs:Comma<Expr>> <catch:TryCatch>
        => Expr::Try { span: span!(l, catch.2), exprs: None, clauses: None, catch_clauses: catch.0, after: catch.1 }
};

TryCatch: (Option<Vec<TryClause>>, Option<Vec<Expr>>, ByteIndex) = {
    "catch" <clauses:Semi<TryClause>> "end" <r:@R>
        => (Some(clauses), None, r),
    "catch" <clauses:Semi<TryClause>> "after" <body:Comma<Expr>> "end" <r:@R>
        => (Some(clauses), Some(body), r),
    "after" <body:Comma<Expr>> "end" <r:@R>
        => (None, Some(body), r)
};

TryClause: TryClause = {
    <l:@L> <error:Pattern> <guard:Guards?> "->" <body:Comma<Expr>> <r:@R>
        => TryClause { span: span!(l, r), kind: Name::Atom(Ident::from_str("throw")), error, guard, trace: Ident::from_str("_"), body },
    <l:@L> <kind:atom_or_var> ":" <error:Pattern> <guard:Guards?> "->" <body:Comma<Expr>> <r:@R>
        => TryClause { span: span!(l, r), kind, error, guard, trace: Ident::from_str("_"), body },
    <l:@L> <kind:atom_or_var> ":" <error:Pattern> ":" <trace:Ident> <guard:Guards?> "->" <body:Comma<Expr>> <r:@R>
        => TryClause { span: span!(l, r), kind, error, guard, trace, body },
};

Clause: Clause = {
    <l:@L> <pattern:Pattern> <guard:Guards?> "->" <body:Comma<Expr>> <r:@R>
        => Clause { span: span!(l, r), pattern, guard, body }
};

Apply: Expr = {
    <l:@L> <lhs:Expr800> "(" ")" <r:@R>
        => Expr::Apply { span: span!(l, r), lhs: Box::new(lhs), args: Vec::new()  },
    <l:@L> <lhs:Expr800> "(" <args:Comma<Expr>> ")" <r:@R>
        => Expr::Apply { span: span!(l, r), lhs: Box::new(lhs), args }
};

ListComprehension: Expr = {
    <l:@L> "[" <output:Expr> "||" <lc_exprs:Comma<ComprehensionExpr>> "]" <r:@R>
        => Expr::ListComprehension(span!(l, r), Box::new(output), lc_exprs),
};

BinaryComprehension: Expr = {
    <l:@L> "<<" <output:ExprMax> "||" <lc_exprs:Comma<ComprehensionExpr>> ">>" <r:@R>
        => Expr::BinaryComprehension(span!(l, r), Box::new(output), lc_exprs),
};

ComprehensionExpr: Expr = {
    <l:@L> <lhs:Binary> "<=" <rhs:Expr> <r:@R>
        => Expr::BinaryGenerator(span!(l, r), Box::new(lhs), Box::new(rhs)),
    <l:@L> <lhs:Expr> "<-" <rhs:Expr> <r:@R>
        => Expr::Generator(span!(l, r), Box::new(lhs), Box::new(rhs)),
    Expr,
};

Binary: Expr = {
    <l:@L> "<<" ">>" <r:@R>
        => Expr::Binary(span!(l, r), Vec::new()),
    <l:@L> "<<" <elements:Comma<BinaryElement>> ">>" <r:@R>
        => Expr::Binary(span!(l, r), elements),
};

BinaryElement: BinaryElement = {
    <l:@L> <be:BitExpr> <bs:BitSize?> <bt:BitTypeList?> <r:@R>
        => BinaryElement { span: span!(l, r), bit_expr: be, bit_size: bs, bit_type: bt },
};

BitExpr: Expr = {
    <l:@L> <op:PrefixOp> <rhs:ExprMax> <r:@R>
        => Expr::UnaryExpr { span: span!(l, r), op, rhs: Box::new(rhs) },
    ExprMax,
};

BitSize: Expr = {
    ":" <ExprMax>,
};

BitTypeList: Vec<BitType> = {
    "/" <bts:Dash<BitType>> => bts,
};

BitType: BitType = {
    <l:@L> <ty:atom> ":" <i:int> <r:@R>
        => BitType::Sized(span!(l, r), ty, i),
    <l:@L> <ty:atom> <r:@R>
        => BitType::Name(span!(l, r), ty)
};

Tuple: Expr = {
    <l:@L> "{" "}" <r:@R>
        => Expr::Tuple(span!(l, r), Vec::new()),
    <l:@L> "{" <elements:Comma<Expr>> "}" <r:@R>
        => Expr::Tuple(span!(l, r), elements)
};

List: Expr = {
    <l:@L> "[" "]" <r:@R> => Expr::Nil(span!(l, r)),
    <l:@L> "[" <head:Expr> <tail:Tail> <r:@R> => Expr::Cons(span!(l, r), Box::new(head), Box::new(tail))
};

Tail: Expr = {
    <l:@L> "]" <r:@R>
        => Expr::Nil(span!(l, r)),
    "|" <Expr> "]",
    <l:@L> "," <head:Expr> <tail:Tail> <r:@R>
        => Expr::Cons(span!(l, r), Box::new(head), Box::new(tail))
};

MapExpr: Expr = {
    <l:@L> "#" <fields:MapTuple> <r:@R>
        => Expr::Map(span!(l, r), None, fields),
    <l:@L> <lhs:ExprMax> "#" <fields:MapTuple> <r:@R>
        => Expr::Map(span!(l, r), Some(Box::new(lhs)), fields),
    <l:@L> <lhs:MapExpr> "#" <fields:MapTuple> <r:@R>
        => Expr::Map(span!(l, r), Some(Box::new(lhs)), fields),
};

MapTuple: Vec<MapField> = {
    "{" "}" => Vec::new(),
    "{" <Comma<MapField>> "}"
};

MapField: MapField = {
    MapFieldAssoc,
    MapFieldExact
};
MapFieldAssoc: MapField = {
    <l:@L> <key:MapKey> "=>" <value:Expr> <r:@R> => MapField::Assoc { span: span!(l, r), key, value }
};
MapFieldExact: MapField = {
    <l:@L> <key:MapKey> ":=" <value:Expr> <r:@R> => MapField::Exact { span: span!(l, r), key, value }
};

MapKey: Expr = Expr;

RecordExpr: Expr = {
    <l:@L> "#" <name:atom> "." <field:atom> <r:@R>
        => Expr::RecordIndex(span!(l, r), name, field),
    <l:@L> "#" <name:atom> <fields:RecordTuple> <r:@R>
        => Expr::Record(span!(l, r), name, fields),

    <l:@L> <lhs:ExprMax> "#" <name:atom> "." <field:atom> <r:@R>
        => Expr::RecordAccess(span!(l, r), Box::new(lhs), name, field),
    <l:@L> <lhs:ExprMax> "#" <name:atom> <fields:RecordTuple> <r:@R>
        => Expr::RecordUpdate(span!(l, r), Box::new(lhs), name, fields),

    <l:@L> <lhs:RecordExpr> "#" <name:atom> "." <field:atom> <r:@R>
        => Expr::RecordAccess(span!(l, r), Box::new(lhs), name, field),
    <l:@L> <lhs:RecordExpr> "#" <name:atom> <fields:RecordTuple> <r:@R>
        => Expr::RecordUpdate(span!(l, r), Box::new(lhs), name, fields),
};

RecordTuple: Vec<RecordField> = {
    "{" "}" => Vec::new(),
    "{" <Comma<RecordField>> "}"
};

RecordField: RecordField = {
    <l:@L> <name:atom_or_var> "=" <value:Expr> <r:@R>
        => RecordField { span: span!(l, r), name, value: Some(value), ty: None },
};

Atomic: Expr = {
    <l:@L> <c:char> <r:@R> => Expr::Literal(Literal::Char(span!(l, r), c)),
    <Integer> => Expr::Literal(<>),
    <l:@L> <f:float> <r:@R> => Expr::Literal(Literal::Float(span!(l, r), f)),
    <atom> => Expr::Literal(Literal::Atom(<>)),
    <l:@L> <s:string> <r:@R> => {
        Expr::Literal(Literal::String(Ident::new(s, span!(l, r))))
    }
};

#[inline]
atom_or_var: Name = {
    <a:atom> => Name::Atom(a),
    <i:Ident> => Name::Var(i),
};

#[inline]
atom: Ident = <l:@L> <a:"atom"> <r:@R>
    => Ident::new(a, span!(l, r));

#[inline]
Ident: Ident = <l:@L> <i:ident> <r:@R>
    => Ident::new(i, span!(l, r));

#[inline]
Integer: Literal = {
    <l:@L> <i:int> <r:@R> => Literal::Integer(span!(l, r), i),
    <l:@L> <i:bigint> <r:@R> => Literal::BigInteger(span!(l, r), i)
};

#[inline]
arity: usize = <i:int> => i as usize;

#[inline]
ident_or_integer: Expr = {
    <i:Ident> => Expr::Var(i),
    <i:Integer> => Expr::Literal(i)
}

PrefixOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "bnot" => UnaryOp::Bnot,
    "not" => UnaryOp::Not,
};

MultOp: BinaryOp = {
    "/" => BinaryOp::Divide,
    "*" => BinaryOp::Multiply,
    "div" => BinaryOp::Div,
    "rem" => BinaryOp::Rem,
    "band" => BinaryOp::Band,
    "and" => BinaryOp::And,
};

AddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
    "bor" => BinaryOp::Bor,
    "bxor" => BinaryOp::Bxor,
    "bsl" => BinaryOp::Bsl,
    "bsr" => BinaryOp::Bsr,
    "or" => BinaryOp::Or,
    "xor" => BinaryOp::Xor,
};

TypeMultOp: BinaryOp = {
    "*" => BinaryOp::Multiply,
    "div" => BinaryOp::Div,
    "rem" => BinaryOp::Rem,
    "band" => BinaryOp::Band,
};

TypeAddOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
    "bor" => BinaryOp::Bor,
    "bxor" => BinaryOp::Bxor,
    "bsl" => BinaryOp::Bsl,
    "bsr" => BinaryOp::Bsr,
};

TypeUnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "bnot" => UnaryOp::Bnot,
};

ListOp: BinaryOp = {
    "++" => BinaryOp::Append,
    "--" => BinaryOp::Remove,
};

CompOp: BinaryOp = {
    "==" => BinaryOp::Equal,
    "/=" => BinaryOp::NotEqual,
    "=<" => BinaryOp::Lte,
    "<" => BinaryOp::Lt,
    ">=" => BinaryOp::Gte,
    ">" => BinaryOp::Gt,
    "=:=" => BinaryOp::StrictEqual,
    "=/=" => BinaryOp::StrictNotEqual
};

extern {
    type Location = ByteIndex;
    type Error = PreprocessorError;

    enum Token {
        // Docs
        "COMMENT" => Token::Comment,
        // Literals
        char => Token::Char(<char>),
        int => Token::Integer(<i64>),
        bigint => Token::BigInteger(<Integer>),
        float => Token::Float(<f64>),
        "atom" => Token::Atom(<Symbol>),
        string => Token::String(<Symbol>),
        ident => Token::Ident(<Symbol>),
        // Keywords and Symbols
        "(" => Token::LParen,
        ")" => Token::RParen,
        "," => Token::Comma,
        "->" => Token::RightStab,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "|" => Token::Bar,
        "||" => Token::BarBar,
        "<-" => Token::LeftStab,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "#" => Token::Pound,
        "." => Token::Dot,
        "after" => Token::After,
        "begin" => Token::Begin,
        "case" => Token::Case,
        "try" => Token::Try,
        "catch" => Token::Catch,
        "end" => Token::End,
        "fun" => Token::Fun,
        "if" => Token::If,
        "of" => Token::Of,
        "receive" => Token::Receive,
        "when" => Token::When,
        "record" => Token::Record,
        "spec" => Token::Spec,
        "callback" => Token::Callback,
        "import" => Token::Import,
        "export" => Token::Export,
        "export_type" => Token::ExportType,
        "module" => Token::Module,
        "compile" => Token::Compile,
        "vsn" => Token::Vsn,
        "on_load" => Token::OnLoad,
        "behaviour" => Token::Behaviour,
        "type" => Token::Type,
        "opaque" => Token::Opaque,
        "andalso" => Token::AndAlso,
        "orelse" => Token::OrElse,
        "bnot" => Token::Bnot,
        "not" => Token::Not,
        "*" => Token::Star,
        "/" => Token::Slash,
        "div" => Token::Div,
        "rem" => Token::Rem,
        "band" => Token::Band,
        "and" => Token::And,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "bor" => Token::Bor,
        "bxor" => Token::Bxor,
        "bsl" => Token::Bsl,
        "bsr" => Token::Bsr,
        "or" => Token::Or,
        "xor" => Token::Xor,
        "++" => Token::PlusPlus,
        "--" => Token::MinusMinus,
        "==" => Token::IsEqual,
        "/=" => Token::IsNotEqual,
        "=<" => Token::IsLessThanOrEqual,
        "<" => Token::IsLessThan,
        ">=" => Token::IsGreaterThanOrEqual,
        ">" => Token::IsGreaterThan,
        "=:=" => Token::IsExactlyEqual,
        "=/=" => Token::IsExactlyNotEqual,
        "<=" => Token::LeftArrow,
        "=>" => Token::RightArrow,
        ":=" => Token::ColonEqual,
        "<<" => Token::BinaryStart,
        ">>" => Token::BinaryEnd,
        "!" => Token::Bang,
        "=" => Token::Equals,
        "::" => Token::ColonColon,
        ".." => Token::DotDot,
        "..." => Token::DotDotDot,
        "?" => Token::Question,
    }
}
